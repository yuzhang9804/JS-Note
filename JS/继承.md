## 继承

>`ES5`继承

- 组合继承

  ```javascript
  function Person(name) {
      this.name = name;
  }
  Person.prototype.shout = function(){
      console.log(`Hello! ${this.name}`);
  }
  
  // 组合继承
  function Child(name){
      Person.call(this, name);
  }
  Child.prototype = new Person();
  Child.prototype.constructor = Child;
  let child = new Child(`yuzhang`);
  console.log(child.name);        // yuzhang
  child.shout();                  // Hello! yuzhang
  
  ```

  

组合继承的核心是在子类构造函数中通过==Person.call(this)==继承父类的属性, 然后改变子类的原型为==new Person()== 来继承父类的方法

  >优点:	构造函数可以传参, 不会与父类引用属性共享, 可以复用父类函数
  >
  >缺点:	继承父类函数的时候调用了父类构造函数, 导致子类的原型上多了不需要的父类属性, 存在内存浪费



- 寄生组合继承

```javascript
// 寄生组合继承
function Child(name) {
    Person.call(this, name);
}
Child.prototype = Object.create(Person.prototype, {
    constructor: {
        value: Child,
        enumerable: false,
        writable: true,
        configurable: true
    }
})
let child = new Child(`yuzhang`);
console.log(child.name);        // yuzhang
child.shout();                  // Hello! yuzhang
console.log(child);
```



寄生组合继承的核心就是将父类的原型赋给子类, 并将构造函数设为子类

- class 继承

```javascript
// class 继承
class Parent {
    constructor(name) {
        this.name = name;
    }
    shout() {
        console.log(`Hello, ${this.name}`);
        
    }
}
console.log(new Parent('zs').name);
new Parent('zs').shout();
class Girl extends Parent  {
    constructor(name){
        super(name);
    }
}
console.log(new Girl(`Lisa`).name);
new Girl('Lisa').shout();
```

> ==class== 继承的核心就是利用==exdents==表明继承自哪个父类, `JavaSscript`不存在类, ==class==只是语法糖, 本质上还是函数
