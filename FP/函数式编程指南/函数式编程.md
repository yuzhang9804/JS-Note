### 纯函数

##### 纯函数的概念

> 纯函数是一种函数, 即相同的输入, 永远会得到相同的输出, 而且没有任何可观察的副作用



##### 何为副作用

> 副作用实在计算过程中, 系统状态的一种改变, 或者与外部世界进行的可观察性的交互

副作用可能包含, 但不限于

- 更改文件系统
- 往数据库插入数据
- 发送一个`http`请求
- 改变数据
- 打印数据
- 获取用户输入
- DOM查询
- 访问系统状态
- ...........

只要和函数外部环境发生的额外交互都是副作用



#### 函数的输入和输出

>函数是不同数值之间的特殊关系, 每一个输入值返回其只返回一个输入值

函数只是两种数值之前的关系:  输入和输出,  尽管每个输入只会有一个输出, 但不同的输入可以有相同的输出



#### 追求 '纯' 的理由

##### 可缓存性 (`Cacheable`)

> 纯函数能够根据输入来做缓存,  实现缓存的方式是`memoize` 技术

##### 可移植性 / 自动文档化 ( Portable / Self-Documenting)

> 纯函数是完全自给自足的, 它需要的所有东西都能够轻易获得

##### 可测试性 (Testable)

##### 合理性 (Reasonable)

##### 并行代码



### 柯里化 (curry)

柯里化的概念

> 只传递参数的一部分来调用它, 让它返回一个函数去处理剩下的参数

```javascript
const add = x => y => x + y;
const increment = add(10);
increment(5);  // 15	
```

#### 代码组合(compose)

##### 函数饲养

> 将两个函数组合之后返回一个新的函数

```javascript
const compose = (f, g) => x => f(g(x));
```

`f` 和 `g` 都是函数, `x` 是它们之间通过**管道**传输的值



##### `pointfree`

> 函数无需提及将要操作的数据是什么样的, 即脱离数据的代码风格, 做到**行为和代码分离**



### 容器

创建一个容器, 能包含任意值

```javascript
const Container = function (x) {
  this._value = x;
}

Container.of = function (x) {
  return new Container(x);
}

Container.of(3);  // Container {_value: 3}

Container.of('Yu Zhang');  // Container {_value: 'Yu Zhang'}
Container.of(Container.of({name: 'Stark'}));  
// Container {_value: Container {_value: {name: 'Stark'}}}
```

- `Container`是个只有一个属性的对象, 尽管容器可以不止有一个属性, 但大多数容器还是只有一个, 我们很随意的把`Constainer`的这个属性定义为`_value`
- `_value`不是某个特定的类型
- 数据一旦存放到`Container`,  就会一直待在那儿, 我们可以用`._value`获取到数据, 按这样做有悖初衷



#### Functor

> functor 是实现 map 函数并遵守一些特定规则的容器类型

```javascript
// (a -> b) -> Container a -> Container b
Container.prototype.map = function (f) {
  return Container.of(f(this._value));
}

Container.of(10).map(x => x + 1);  // Container {_value: 11}
```



#### Maybe

> 另一中 functor 每次调用会判断是否为空

```javascript
const Maybe = function (x) {
  this._value = x;
}
Maybe.of = function (x) {
  return new Maybe(x);
}
Maybe.prototype.isNothing = function () {
  return (this._value === null || this._value === undefined);
}
Maybe.prototype.map = function (f) {
  return Maybe.of(this.isNothing() ? null : f(this._value));
}
// 当 map 值为空时, 代码并没有报错, 这是因为每次函数调用四 Maybe 都会检查它自己的值是否为空
Maybe.of(undefined).map(x => x + 1);  // Maybe {_value: null}
```

实际场景中,  `Maybe`最常用在那些可能无法成功返回结果的函数中

